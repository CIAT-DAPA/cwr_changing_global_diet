ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
ta1 <- rnorm(n = 18)
ta2 <- rnorm(n = 18)
cor(ta1, ta2)
plot(ta1, ta2)
library(h2o)
localH2o = h2o.init()
demo(h2o.kmeans())
data('Seatbelts')
dim(Seatbelts)
train <- as.h2o(Seatbelts)
model <- h2o.deeplearning(x = colnames(train[2:8]), y = 'DriversKilled', training_frame = train)
model
model@model
model@allparameters
model@parameters
model@algorithm
model@model_id
model@model$model_summary
model@model$scoring_history
model@parameters$y
model@parameters$x
g = gc()
rm(list=ls())
install.packages(c("acepack", "drat", "openssl", "qgraph", "survival"))
install.packages('fractal')
library(fractal)
data(beamchaos)
plot(beamchaos)
install.packages("survival")
options(warn = -1)
options(scipen = 999)
suppressMessages(library(rgdal))
suppressMessages(library(raster))
suppressMessages(library(caret))
suppressMessages(library(rgdal))
suppressMessages(library(raster))
suppressMessages(library(caret))
list.files2(path = 'D:/Harold/_maps/landsat/images/2000/LE70070572000028EDC00/LE70070572000028EDC00_ref/', full.names = T, recursive = F)
img <- raster::brick('D:/Harold/_maps/landsat/images/2000/LE70070572000028EDC00/LE70070572000028EDC00_ref')
list.files(path = 'D:/Harold/_maps/landsat/images/2000/LE70070572000028EDC00/LE70070572000028EDC00_ref')
list.files(path = 'D:/Harold/_maps/landsat/images/2000/LE70070572000028EDC00/', full.names = T)
imgList <- list.files(path = 'D:/Harold/_maps/landsat/images/2000/LE70070572000028EDC00/', full.names = T)
imgList
paste("/B", c(1:5, 7), '_dn_ref.tif', sep = '')
grep2 <- Vectorize(FUN = grep, vectorize.args = 'pattern')
grep2(pattern = paste("/B", c(1:5, 7), '_dn_ref.tif', sep = ''), x = imgList)
imgList <- imgList[grep2(pattern = paste("/B", c(1:5, 7), '_dn_ref.tif', sep = ''), x = imgList)]
imgList
img <- lapply(imgList, function(x){
z <- raster::raster(x)
return(z)
})
img <- brick(img)
g = gc()
rm(list=ls())
# R options
options(warn = -1)
options(scipen = 999)
# load packages
suppressMessages(library(rgdal))
suppressMessages(library(raster))
suppressMessages(library(caret))
imgList <- list.files(path = 'D:/Harold/_maps/landsat/images/2000/LE70070572000028EDC00', full.names = T)
grep2 <- Vectorize(FUN = grep, vectorize.args = 'pattern')
imgList <- imgList[grep2(pattern = paste("/B", c(1:5, 7), '_dn_ref.tif', sep = ''), x = imgList)]
img <- brick(imgList)
img <- raster::brick(imgList)
img <- raster::stack(imgList)
img
c(paste0("B", 1:5, coll = ""), "B7")
names(img) <- c(paste0("B", 1:5, coll = ""), "B7")
rm(imgList)
img
plotRGB(img * (img >= 0), r = 4, g = 5, b = 3, scale = 10000)
plot(img[[1]])
plot(img[[3]])
plot(img[[2]])
plot(img)
options(warn = -1)
options(scipen = 999)
# load packages
suppressMessages(library(rgdal))
suppressMessages(library(raster))
suppressMessages(library(caret))
imgList <- list.files(path = 'D:/Harold/_maps/landsat/images/2000/LE70070572000044EDC00', full.names = T)
grep2 <- Vectorize(FUN = grep, vectorize.args = 'pattern')
imgList <- imgList[grep2(pattern = paste("/B", c(1:5, 7), '_dn_ref.tif', sep = ''), x = imgList)]
img <- raster::stack(imgList); rm(imgList)
names(img) <- c(paste0("B", 1:5, coll = ""), "B7")
plot(img)
plot(img[[3]])
plot(img)
g = gc()
rm(list=ls())
options(warn = -1)
options(scipen = 999)
# load packages
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(ggplot2))
suppressMessages(library(caroline))
suppressMessages(library(purrr))
suppressMessages(library(broom))
suppressMessages(library(ggplot2))
options(warn = -1)
options(scipen = 999)
# load packages
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(ggplot2))
suppressMessages(library(caroline))
suppressMessages(library(purrr))
suppressMessages(library(broom))
suppressMessages(library(ggplot2))
suppressMessages(library(epanetReader))
install.packages(c("aqp", "installr", "randomForestSRC"))
install.packages('covr')
suppressMessages(library(lazyeval))
suppressMessages(library(lazyeval))
(library(lazyeval))
library(lazyeval)
library(lazyeval)
library(lubridate)
library(memoise)
library(roxygen2)
install.packages('roxygen2')
library(stringr)
library(testthat)
library(tibble)
sqrt_newton <- function(a, init, eps = 0.01){
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
}
return(init)
}
sqrt_newton(16, 2)
sqrt_newton(16, 2)
sqrt_newton_recur <- function(a, init, eps = 0.01){
if(abs(init**2 - a) < eps){
result <- init
} else {
init <- 1/2 * (init + a/init)
result <- sqrt_newton_recur(a, init, eps)
}
return(result)
}
sqrt_newton_recur(16, 2)
sqrt_newton_recur <- function(a, init, eps = 0.01){
if(abs(init**2 - a) < eps){
result <- init
} else {
init <- 1/2 * (init + a/init)
result <- sqrt_newton_recur(a, init, eps)
}
return(result)
}
numbers <- c(16, 25, 36, 49, 64, 81)
sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
Map(sqrt_newton, numbers, init = 1)
sqrt_newton(a = 16, init = 2)
numbers <- c(16, 25, 36, 49, 64, 81)
sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
Map(sqrt_newton, numbers, init = 1)
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(Map(sqrt_newton, numbers, init, eps))
}
sqrt_newton_vec(numbers, 1)
profvis::profvis({sqrt_newton <- function(a, init, eps = 0.01){
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
}
return(init)
}
sqrt_newton(a = 16, init = 2)
# Apply this function to a vector of numbers
# Option 1: returns a vector with the answers but also warning messages
numbers <- c(16, 25, 36, 49, 64, 81)
sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
# Option 2: returns a list with the answers without errors
Map(sqrt_newton, numbers, init = 1)
# Map() applies a function to every element of a list and returns a list
# Option 3
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(Map(sqrt_newton, numbers, init, eps))
}
sqrt_newton_vec(numbers, 1)})
profvis::profvis({sqrt_newton <- function(a, init, eps = 0.01){
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
}
return(init)
}
sqrt_newton(a = 16, init = 2)
# Apply this function to a vector of numbers
# Option 1: returns a vector with the answers but also warning messages
numbers <- c(16, 25, 36, 49, 64, 81)
sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
# Option 2: returns a list with the answers without errors
Map(sqrt_newton, numbers, init = 1)
# Map() applies a function to every element of a list and returns a list
# Option 3
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(Map(sqrt_newton, numbers, init, eps))
}
sqrt_newton_vec(numbers, 1)})
profvis::profvis({# Apply this function to a vector of numbers
# Option 1: returns a vector with the answers but also warning messages
numbers <- c(16, 25, 36, 49, 64, 81)
sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
# Option 2: returns a list with the answers without errors
Map(sqrt_newton, numbers, init = 1)
# Map() applies a function to every element of a list and returns a list
# Option 3
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(Map(sqrt_newton, numbers, init, eps))
}
sqrt_newton_vec(numbers, 1)})
lapply(numbers, sqrt_newton, init = 1)
sapply(numbers, sqrt_newton, init = 1)
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(sapply(numbers, sqrt_newton, init, eps))
}
sqrt_newton_vec(numbers, 1)
inits <- c(100, 20, 3212, 487, 5, 9888)
mapply(sqrt_newton, numbers, init = inits)
Reduce(`+`, numbers, init = 0)
sum(numbers)
Reduce(my_min, numbers)
my_min <- function(a, b){
if(a < b){
return(a)
} else {
return(b)
}
}
Reduce(my_min, numbers)
min(numbers)
profvis::profvis({sqrt_newton <- function(a, init, eps = 0.01){
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
}
return(init)
}
sqrt_newton(a = 16, init = 2)
## Map() uses
# Apply this function to a vector of numbers
# Option 1: returns a vector with the answers but also warning messages
numbers <- c(16, 25, 36, 49, 64, 81)
sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
# Option 2: returns a list with the answers without errors
Map(sqrt_newton, numbers, init = 1)
# Map() applies a function to every element of a list and returns a list
# Option 3
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(Map(sqrt_newton, numbers, init, eps))
}
sqrt_newton_vec(numbers, 1)
# Option 4
lapply(numbers, sqrt_newton, init = 1)
# Option 5
sapply(numbers, sqrt_newton, init = 1)
# Option 6
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(sapply(numbers, sqrt_newton, init, eps))
}
sqrt_newton_vec(numbers, 1)
# Option 7
inits <- c(100, 20, 3212, 487, 5, 9888)
mapply(sqrt_newton, numbers, init = inits)})
profvis::profvis({sqrt_newton <- function(a, init, eps = 0.01){
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
}
return(init)
}
sqrt_newton(a = 16, init = 2)
## Map() uses
# Apply this function to a vector of numbers
# Option 1: returns a vector with the answers but also warning messages
numbers <- c(16, 25, 36, 49, 64, 81)
sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
# Option 2: returns a list with the answers without errors
Map(sqrt_newton, numbers, init = 1)
# Map() applies a function to every element of a list and returns a list
# Option 3
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(Map(sqrt_newton, numbers, init, eps))
}
sqrt_newton_vec(numbers, 1)
# Option 4
lapply(numbers, sqrt_newton, init = 1)
# Option 5
sapply(numbers, sqrt_newton, init = 1)
# Option 6
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(sapply(numbers, sqrt_newton, init, eps))
}
sqrt_newton_vec(numbers, 1)
# Option 7
inits <- c(100, 20, 3212, 487, 5, 9888)
mapply(sqrt_newton, numbers, init = inits)})
profvis::profvis({sqrt_newton <- function(a, init, eps = 0.01){
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
}
return(init)
}
sqrt_newton(a = 16, init = 2)
## Map() uses
# Apply this function to a vector of numbers
# Option 1: returns a vector with the answers but also warning messages
numbers <- c(16, 25, 36, 49, 64, 81)
res <- sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
# Option 2: returns a list with the answers without errors
res <- Map(sqrt_newton, numbers, init = 1)
# Map() applies a function to every element of a list and returns a list
# Option 3
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(Map(sqrt_newton, numbers, init, eps))
}
res <- sqrt_newton_vec(numbers, 1)
# Option 4
res <- lapply(numbers, sqrt_newton, init = 1)
# Option 5
res <- sapply(numbers, sqrt_newton, init = 1)
# Option 6
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
return(sapply(numbers, sqrt_newton, init, eps))
}
res <- sqrt_newton_vec(numbers, 1)
# Option 7
inits <- c(100, 20, 3212, 487, 5, 9888)
res <- mapply(sqrt_newton, numbers, init = inits)})
sqrt_newton(4, 1)
options(warn = -1)
options(scipen = 999)
suppressMessages(library(testthat))
test_that("Test sqrt_newton: positive numeric",{
expected <- 2 # Define the result we expect
actual <- sqrt_newton(4, 1) # Code to test
expect_equal(expected, actual) # Compare
})
test_that("Test sqrt_newton: positive numeric",{
eps <- 0.001
expected <- 2
actual <- sqrt_newton(4, 1, eps = eps)
expect_lt(abs(expected - actual), eps)
})
test_that("Test sqrt_newton: negative numeric",{
expect_error(sqrt_newton(-4, 1))
})
sqrt_newton <- function(a, init, eps = 0.01){
stopifnot(a >= 0)
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
}
return(init)
}
test_that("Test sqrt_newton: negative numeric",{
expect_error(sqrt_newton(-4, 1))
})
sqrt_newton(49, 1E100000, 1E-100000)
sqrt_newton <- function(a, init, eps = 0.01){
stopifnot(a >= 0)
i <- 1
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
i <- i + 1
if(i > 100) stop("Maximum number of iterations reached")
}
return(init)
}
sqrt_newton(49, 1E100, 1E-100)
sqrt_newton <- function(a, init, eps = 0.01, iter = 100){
stopifnot(a >= 0)
i <- 1
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
i <- i + 1
if(i > iter) stop("Maximum number of iterations reached")
}
return(init)
}
test_that("Test sqrt_newton: not enough iterations",{
expect_error(sqrt_newton(4, 1E100, 1E-100, iter = 100))
})
test_file('GitHub/r_scripts/testingFunctions.R')
test_file('GitHub/r_scripts/testingFunctions.R')
source('~/GitHub/cwr_changing_global_diet/r_script/chDiets_data.R', echo=TRUE)
shiny::runApp('C:/Users/haachicanoy/Desktop')
setwd("~/GitHub/cwr_changing_global_diet/r_script/data")
profvis::profvis({options(warn = -1)
options(scipen = 999)
# load packages
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(ggplot2))
suppressMessages(library(caroline))
suppressMessages(library(purrr))
suppressMessages(library(broom))
suppressMessages(library(ggplot2))
suppressMessages(library(epanetReader))
suppressMessages(library(ff))
suppressMessages(library(ffbase))
# load global diet data
# It's better to use Sara's data: CropData_longform.rpt (PENDING)
all_data <- read.csv('all_1961_2009_final_analysis_data_final_2016_10_28.csv')
# load food groups
gFood <- read.csv('FBS_commodities_foodgroups_regions_finaltest.csv')
gFood <- gFood %>% dplyr::select(Item:food_group) %>% unique
# merging global diet and food groups data
all_data2 <- dplyr::left_join(all_data, gFood, by=c('Item'))
rm(all_data, gFood)
# reshape dataset
all_data2 <- all_data2 %>% tidyr::gather(Year, Value, Y1961:Y2009)
all_data2$Year <- as.numeric(gsub(pattern='Y', replacement='', x=all_data2$Year))})
View(all_data2)
unique(all_data2)
unique(all_data2$food_group)
unique(as.character(all_data2$food_group))
View(all_data2)
unique(as.character(all_data2$food_group))
names(all_data2)
all_data3 <- all_data2 %>% group_by(Item, Element, Unit, food_group, Year) %>% summarise(sum(Value))
names(all_data3)[ncol(all_data3)] <- 'Value'
View(all_data3)
all_data3$food_group <- tolower(gsub(pattern = ' ', replacement = '_', x = all_data3$food_group))
all_data3$Item <- as.character(all_data3$Item)
unique(all_data3$Item)
all_data3 <- all_data2 %>% group_by(Item, Element, Unit, food_group, Year) %>% summarise(sum(Value))
names(all_data3)[ncol(all_data3)] <- 'Value'
# change group name
all_data3$food_group <- tolower(gsub(pattern = ' ', replacement = '_', x = all_data3$food_group))
all_data3$Item <- gsub(pattern = '* \\((.*?)\\)', replacement = '', x = all_data3$Item)
all_data3$Item <- tolower(gsub(pattern = ' ', replacement = '-', x = all_data3$Item))
View(all_data3)
measures <- all_data3$Element %>% unique %>% as.character
nicerNms <- c('fat', 'calories', 'food_quantity', 'protein')
measures
nicerNms <- c('fat', 'calories', 'food_quantity', 'protein')
nicerNms
View(all_data3)
i=1
subData <- all_data3 %>% dplyr::filter(Element == measures[i])
subData$Value <- round(subData$Value, 1)
subData$combination <- paste(subData$Item, '_', subData$food_group, sep = '')
subData <- subData[c('Year', 'Value', 'combination')]
subData <- subData %>% spread(key = combination, value = Value)
colnames(subData)[1] <- 'year'
subData <- as.data.frame(subData)
colnames(subData)[ncol(subData)] <- paste(colnames(subData)[ncol(subData)], ',', sep = '')
subData[,ncol(subData)] <- paste(subData[,ncol(subData)], ',', sep='')
View(subData)
rm(i, subData)
measures <- all_data3$Element %>% unique %>% as.character
nicerNms <- c('fat', 'calories', 'food_quantity', 'protein')
lapply(1:length(measures), function(i){
subData <- all_data3 %>% dplyr::filter(Element == measures[i])
subData$Value <- round(subData$Value, 1)
subData$combination <- paste(subData$Item, '_', subData$food_group, sep = '')
subData <- subData[c('Year', 'Value', 'combination')]
subData <- subData %>% spread(key = combination, value = Value)
colnames(subData)[1] <- 'year'
subData <- as.data.frame(subData)
colnames(subData)[ncol(subData)] <- paste(colnames(subData)[ncol(subData)], ',', sep = '')
subData[,ncol(subData)] <- paste(subData[,ncol(subData)], ',', sep='')
# write.delim(subData, paste(nicerNms[i], '.tsv', sep = ''))
write.csv(subData, file = paste('./_data_sources/', nicerNms[i], '_fgroup_&_crop.csv', sep = ''), row.names = FALSE, sep = "|")
})
g=gc()
rm(list = ls())
